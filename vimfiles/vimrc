" Tangled output generated by inweb: do not edit
if &compatible
  set nocompatible
endif

set encoding=utf-8
scriptencoding utf-8

function! OperatingSystem(os) abort
  if !exists('s:operating_system')
      let s:operating_system = "unknown"
  if has("win32")
    let s:operating_system = "windows"
  elseif has("ios")
    let s:operating_system = "ios"
  elseif has("unix")
    let uname = system("uname")
    if uname == "Darwin\n"
      let s:operating_system = "mac"
    elseif uname == "Linux\n"
      let s:operating_system = "linux"
    elseif uname =~ "MINGW64"
      let s:operating_system = "windows"
    endif
  endif


  endif
  return a:os == s:operating_system
endfunction

if has('unix')
  set shell=/bin/sh
endif

filetype plugin indent on

syntax on

let mapleader = ","

nnoremap \ ,
let maplocalleader = "_"

set tabstop=2
set shiftwidth=2
set expandtab

set autoindent
set nocindent
set nosmartindent

if OperatingSystem('windows')
  set fileformats=dos,unix,mac
else
  set fileformats=unix,dos,mac
endif

if exists('+fixeol')
  set nofixeol
endif

set linebreak

if exists('+breakindent')
  set breakindent
endif

set formatoptions=tcqrjn

set nojoinspaces

set whichwrap=b,s,h,l

set backspace=indent,eol,start

set backupdir=$HOME/.vim/backups

if OperatingSystem('windows')
  set directory=.,$TEMP
endif

set incsearch
set hlsearch

set ignorecase
set smartcase

if executable('rg')
  let &grepprg = "rg --vimgrep --hidden"
elseif executable('ag')
  let &grepprg = "ag --vimgrep --hidden"
endif
set grepformat^=%f:%l:%c:%m

set wildmenu

set wildmode=longest:full,full

set completeopt=menu,longest,preview

set display+=lastline

set autoread

set scrolloff=3

set sidescrolloff=10

set hidden

set number

set visualbell

set splitbelow
set splitright

set showmatch
set matchtime=5

set showcmd

let &listchars = "tab:\u25b8 ,eol:\uac,extends:\ubb,precedes:\uab"

if has('gui_running') == 0
  if OperatingSystem('mac')
    " FIXME: Settle on a colorscheme
  elseif OperatingSystem('windows')
    let g:zenburn_high_Contrast=1
    colorscheme zenburn
  elseif OperatingSystem('linux')
    colorscheme zenburn
  endif
endif

function! TweakColorScheme() abort
  if !exists('g:colors_name')
    return
  endif

    if g:colors_name ==? 'zenburn'
    " Highlight tabs like EOLs (less obtrusive)
    highlight! link SpecialKey NonText

    " Override colours used in git diffs
    highlight diffRemoved ctermfg=red
    highlight diffAdded ctermfg=green


    elseif g:colors_name ==? 'solarized'
    " De-emphasize closed folds
    highlight Folded term=bold cterm=bold gui=bold guibg=NONE ctermbg=NONE


    elseif g:colors_name ==? 'inkpot'
    " Highlight code in markdown
    highlight link markdownCode PreProc
    highlight link markdownCodeBlock PreProc
    " De-emphasize closed folds and tabs
    highlight Deemphasized guifg=#555555
    highlight! link Folded Deemphasized
    highlight! link SpecialKey Deemphasized
  endif


endfunction

call TweakColorScheme()

augroup colorschemetweaks
  autocmd!
  autocmd ColorScheme * call TweakColorScheme()
augroup END

augroup highlightwhitespace
  autocmd!
  autocmd InsertEnter * syn clear EOLWS | syn match EOLWS excludenl /\v\s+%#@!$/
  autocmd InsertLeave * syn clear EOLWS | syn match EOLWS excludenl /\v\s+$/
  autocmd ColorScheme * highlight EOLWS guibg=red ctermbg=red
augroup END
highlight EOLWS guibg=red ctermbg=red

augroup cursorline_toggle
  autocmd!
  autocmd WinLeave * setlocal nocursorline
  autocmd WinEnter * setlocal cursorline
augroup END

set laststatus=2

function! FilePathNoName() abort
  let l:path = expand("%:h")
  if !empty(l:path)
    let l:path = l:path . "/"
  endif
  return l:path
endfunction

function! StatuslineModified() abort
  return &modified ? '[+]' : ''
endfunction

function! StatuslineModifiable() abort
  return &modifiable ? '' : '[-]'
endfunction

function! StatuslinePluginItems() abort
    try
    let fugitive_status = fugitive#statusline()
    let gutentags_status = gutentags#statusline()
  catch /^Vim\%((\a\+)\)\=:E117:/ " catch error E117
    return ""
  endtry



  let source_status = fugitive_status
  if !empty(fugitive_status) && !empty(gutentags_status)
    let source_status .= " "
  endif
  let source_status .= gutentags_status

  return source_status
endfunction

set statusline=%{FilePathNoName()}
set statusline+=%#Question#
set statusline+=%t
set statusline+=%*
set statusline+=%r%h%w%q
set statusline+=%#Error#
set statusline+=%{StatuslineModified()}
set statusline+=%*
set statusline+=%{StatuslineModifiable()}
set statusline+=\ %Y,%{&fileformat},%{&fileencoding}
set statusline+=%(\ %{StatuslinePluginItems()}%)
set statusline+=%=
set statusline+=\ hex=%02.4B
set statusline+=\ c%v/%{strlen(getline('.'))}
set statusline+=\ l%l/%L
set statusline+=\ %p%%

command! -bang Cn cn<bang>
command! -bang Q q<bang>
command! -bang Qal qall<bang>
command! -bang Qall qall<bang>
command! -bang Wqall wqall<bang>

command! -complete=option -nargs=* Set set <args>
command! -complete=option -nargs=* Setl setl <args>

cabbrev <expr> W (getcmdtype() == ':' && getcmdpos() == 2) ? 'w' : 'W'
cabbrev <expr> Wq (getcmdtype() == ':' && getcmdpos() == 3) ? 'wq' : 'Wq'

iabbrev unsinged unsigned
iabbrev Pythong Python

" Mappings ---------------------------------------------------------------- {{{

" Esc turns off highlighting {{{
augroup escape_mapping
  autocmd!
  autocmd InsertEnter * call s:setupEscapeMap()
augroup END

function! s:setupEscapeMap()
  nnoremap <Esc> :noh<CR><Esc>
endfunction
" Older, possibly over-engineered version
"if !exists('g:escape_mapped')
"  augroup escape_mapping
"    autocmd!
"    autocmd InsertEnter * call s:setupEscapeMap()
"  augroup END
"endif

"function! s:setupEscapeMap()
"  nnoremap <Esc> :noh<CR><Esc>
"  let g:escape_mapped = 1
"  autocmd! escape_mapping InsertEnter *
"  augroup! escape_mapping
"endfunction
" Thanks to:
"   http://www.viemu.com/blog/2009/06/16/a-vim-and-viemu-mapping-you-really-cant-miss-never-type-noh-again/
" Need to be setup in an autocmd because it inteferes with startup terminal
" escape codes:
"   https://vi.stackexchange.com/questions/2614/why-does-this-esc-nmap-affect-startup
"
"
"

" }}}
" Always use very magic searches {{{

nnoremap / /\v
nnoremap ? ?\v

" }}}
" RISC OS style F3 saving {{{

nnoremap #3 :browse w<CR>

" }}}
" Quick email reformat (Re-wRap) {{{

" No longer use par: it doesn't support format=flowed
"nnoremap <leader>rr vip:!par -q 72<CR>
"vnoremap <leader>rr :!par -q 72<CR>

" A plain `gq` will not join short lines if 'formatoptions' contains `w`. We
" must first join them.
" N.B. Make sure 'formatoptions' contains `j` before using this mapping!
nnoremap <leader>rr vipJgvgqo<Esc>
vnoremap <leader>rr Jgvgq

" }}}
" Easy vimrc Access {{{

" Source vimrc
nnoremap <leader>vs :source $MYVIMRC<cr>

" Edit vimrc
nnoremap <leader>ve :vsplit $MYVIMRC<cr>

" }}}
" Navigate wrapped lines visually by default {{{

noremap j gj
noremap gj j
noremap k gk
noremap gk k

" }}}
" Quicker window nav {{{
noremap <C-J> <C-W>j
noremap <C-K> <C-W>k
noremap <C-H> <C-W>h
noremap <C-L> <C-W>l
" }}}
" Use arrow keys for quickfix {{{

nnoremap <up> :cwindow<CR>
nnoremap <down> :cc<CR>
nnoremap <left> :cp<CR>
nnoremap <right> :cn<CR>
noremap! <left> <nop>
noremap! <right> <nop>
" We want to be able to use up and down for accessing command/search history
inoremap <up> <nop>
inoremap <down> <nop>

" }}}
" Disable Ex mode {{{
nnoremap Q <nop>
" }}}
" Setting toggles {{{
" Turning spell checking on and off {{{
nnoremap <leader>s :setlocal spell!<cr>:set spell?<cr>
" }}}
" Turning list on and off {{{
nnoremap <leader>l :setlocal list!<cr>:set list?<cr>
" }}}
" Turn expandtab on and off {{{
nnoremap <leader>e :setlocal expandtab!<cr>:set expandtab?<cr>
" }}}
" Turning wrap on and off {{{
nnoremap <leader>w :setlocal nowrap!<cr>:set wrap?<cr>
" }}}
" Turn colour column on and off {{{
function! ToggleColorColumn()
  if ! &colorcolumn
    if !exists("b:oldcolorcolumn")
      let b:oldcolorcolumn = 81
    endif
    execute "setlocal colorcolumn=" . b:oldcolorcolumn
  else
    let b:oldcolorcolumn = &l:colorcolumn
    setlocal colorcolumn=
  endif
endfunction

nnoremap <silent> <leader>c :call ToggleColorColumn()<cr>
" }}}
" Calculator {{{
vnoremap <leader>cal y`>a = <c-r>=<c-r>0<cr><esc>:nohls<cr>
"nnoremap <leader>cal yiWEa = <c-r>=<c-r>0<cr><esc>
"nnoremap <leader>cal v?[0-9. ()*/+-]*<cr>y``a = <c-r>=<c-r>0<cr><esc>
nnoremap <leader>cal :let cal_wrap=&whichwrap<cr>:set whichwrap-=l<cr>:silent! normal l<cr>:silent! normal l<cr>?\d[0-9. ()*/+-]*<cr>y/[0-9. ()*/+-]*\d/e<cr>`]a = <c-r>=<c-r>0<cr><esc>:nohls<cr>:let &whichwrap=cal_wrap<cr>

" }}}
" }}}
" Don't search when using * and # {{{
nnoremap * *<C-o>
nnoremap # #<C-o>
" }}}
" Sane behaviour of Y (i.e. like C and D) {{{
nnoremap Y y$
" }}}
" Smart quotes {{{
nnoremap <leader>sq1 :%s/\v '(.{-})'/ \&lsquo;\1\&rsquo;/gc<cr>
nnoremap <leader>sq2 :%s/\v "(.{-})"/ \&ldquo;\1\&rdquo;/gc<cr>
nnoremap <leader>sa :%s/'/\&rsquo;/gc<cr>
" }}}
" Find in Files {{{
nnoremap <leader>ff :grep <C-R><C-W><C-F>hviw<C-G>
" This is literally the only thing I use select mode for, so I think this is
" safe to map globally. If it becomes a problem, map in CmdwinEnter autocommand.
snoremap <CR> <Esc><CR>
" }}}
" Invoke Make {{{
nnoremap <leader>mm :Make<cr>
" }}}
" File Jumps. Ctrl-O/Ctrl-I skipping current file {{{
" Skip entries in the jumplist that are in the same file
function! s:jump_skipping_file(backwards) abort
  let this_buffer = bufnr('%')
    while this_buffer == bufnr('%')
      execute "normal!" a:backwards ? "\<C-O>" : "1\<C-I>"
    endwhile
endfunction
nnoremap <leader><C-O> :call <SID>jump_skipping_file(v:true)<CR>
nnoremap <leader><C-I> :call <SID>jump_skipping_file(v:false)<CR>
" }}}
" Dictionary completion with 'nospell' {{{
"
" Dictionary completion of natural language words only works if either 'spell'
" or 'dictionary' is set. If neither is set, set 'spell' temporarily to allow
" completion.
"
inoremap <expr> <C-X><C-K> !empty(&dictionary) <bar><bar> &spell ? '<C-X><C-K>' : '<C-O>:call <SID>dictionary_complete_nospell()<CR><C-X><C-K>'

function! s:dictionary_complete_nospell() abort
  set spell
  augroup dictionary_complete_nospell
    autocmd!
    autocmd CompleteDone <buffer> ++once set nospell
  augroup END
endfunction
" }}}
" Faster tselect {{{
nnoremap <leader><C-]> :tselect <C-R><C-W><CR>
" }}}
" Visual mode zz {{{
" FIXME: I wrote this for someone asking on Mastodon, but leaving it here for
"        now so I remember to polish it, and maybe even start using it!
function! s:visual_zz() abort
  let ends = [line('v'), line('.')]
  let top = min(ends)
  let bottom = max(ends)
  let middle = line('w0') + winheight(0) / 2.0 - 0.5

  let delta_top = middle - top
  let delta_bottom = bottom - middle
  if delta_top == delta_bottom
    return ''
  elseif delta_top < delta_bottom
    let command = "\<C-E>"
  else
    let command = "\<C-Y>"
  endif
  let l:count = float2nr(abs(delta_top - delta_bottom)) / 2
  return l:count .. command
endfunction
xnoremap <expr> zz <SID>visual_zz()
" }}}
" }}}

" New Commands ------------------------------------------------------------ {{{
" DiffSaved {{{
function! s:DiffWithSaved()
  let filetype=&ft
  diffthis
  vnew | r # | normal! 1Gdd
  diffthis
  exe "setlocal bt=nofile bh=wipe nobl noswf ro ft=" . filetype
endfunction
command! DiffSaved call s:DiffWithSaved()
" }}}
" SyntaxQuery: Display the syntax stack at current cursor position {{{
function! s:syntax_query() abort
  for id in synstack(line("."), col("."))
    execute 'hi' synIDattr(id, "name")
  endfor
endfunction
command! SyntaxQuery call s:syntax_query()
" }}}
" }}}

let s:blink_length = has('timers') ? 500 : 100

let s:blink_freq = 50

execute printf('nnoremap <silent> n n:call <SID>highlight_next(%d, %d)<cr>', s:blink_length, s:blink_freq)
execute printf('nnoremap <silent> N N:call <SID>highlight_next(%d, %d)<cr>', s:blink_length, s:blink_freq)

function! s:highlight_next(blink_length, blink_freq) abort
    let target_pat = '\c\%#'.@/


  if has('timers')
      call BlinkStop(0)
  call BlinkToggle(target_pat, 0)
  let s:blink_timer_id = timer_start(a:blink_freq, function('BlinkToggle', [target_pat]), {'repeat': -1})
  let s:blink_stop_id = timer_start(a:blink_length, 'BlinkStop')


  else
      " Highlight the match
  let ring = matchadd('ErrorMsg', target_pat, 101)
  redraw
  " Wait
  exec 'sleep ' . a:blink_length . 'm'
  " Remove the highlight
  call matchdelete(ring)
  redraw


  endif
endfunction

if has('timers')
    function! BlinkToggle(target_pat, timer_id)
    if exists('s:blink_match_id')
      " Clear highlight
      call BlinkClear()
    else
      " Set highlight
      let s:blink_match_id = matchadd('ErrorMsg', a:target_pat, 101)
      redraw
    endif
  endfunction


    function! BlinkStop(timer_id)
    " Cancel timers
    if exists('s:blink_timer_id')
      call timer_stop(s:blink_timer_id)
      unlet s:blink_timer_id
    endif
    if exists('s:blink_stop_id')
      call timer_stop(s:blink_stop_id)
      unlet s:blink_stop_id
    endif
    " And clear blink highlight
    if exists('s:blink_match_id')
      call BlinkClear()
    endif
  endfunction


    " Remove the blink highlight
  function! BlinkClear()
    call matchdelete(s:blink_match_id)
    unlet s:blink_match_id
    redraw
  endfunction


    augroup die_blinkmatchen
    autocmd!
    autocmd CursorMoved * call BlinkStop(0)
    autocmd InsertEnter * call BlinkStop(0)
  augroup END


endif

augroup MouseHack
  autocmd!
  autocmd FocusLost * set mouse=
  autocmd FocusGained * call timer_start(200, '<SID>reenable_mouse')
augroup END

function! s:reenable_mouse(timer_id)
  set mouse=a
endfunction

" Use bar cursors in insert mode in terminal Vim -------------------------- {{{

if exists('$TMUX')
  " Surround escape sequences with a DCS sequence and replace <esc> with
  " <esc><esc> for tmux to pass it on to the terminal
  let &t_SI = "\ePtmux;\e\e[5 q\e\\"
  let &t_EI = "\ePtmux;\e\e[2 q\e\\"
else
  let &t_SI = "\e[5 q"
  let &t_EI = "\e[2 q"
endif


" }}}

if OperatingSystem("ios")
  isetekbd insert {'buttons':[
                           \{'keys':[{'title':':',
                                     \'type':'insert',
                                     \'contents':':'}]},
                           \{'keys':[{'title':'~',
                                    \ 'type':'insert',
                                    \ 'contents':'~'}],
                           \'locations':[1]}
                           \],
                \'locations':[10,10]}


isetekbd replace {'buttons':[{'keys':[{'title':'`',
                                     \'type':'insert',
                                     \'contents':'`'}],
                            \'locations':[0]
                            \}],
                \'locations':[9]}




  function! s:vimclippy() abort
  edit vimclippy
  silent put! +
  $delete
  1
  augroup vimclippy
    autocmd!
    autocmd BufWriteCmd vimclippy %yank + | set nomodified
  augroup END
endfunction

command! VimClippy call s:vimclippy()


  let g:gitgutter_enabled = 0


endif

let g:alternateExtensions_h = "c,cpp,cxx,cc,CC,m,mm"
let g:alternateExtensions_H = "C,CPP,CXX,CC,M,MM"
let g:alternateExtensions_cpp = "h,hpp"
let g:alternateExtensions_CPP = "H,HPP"
let g:alternateExtensions_c = "h"
let g:alternateExtensions_C = "H"
let g:alternateExtensions_cxx = "h"
let g:alternateExtensions_m = "h"
let g:alternateExtensions_mm = "h"

let g:ctrlp_map = '<leader><leader>'
" Start in buffer mode. Then press <c-f> for MRU, <c-b> for file search
let g:ctrlp_cmd = 'CtrlPBuffer'
" Search file names (not full paths) by default. Press <c-d> to toggle
let g:ctrlp_by_filename = 1
" Set working directory based on current file, pwd if an ancestor, nearest
" ancestor with a .git file
let g:ctrlp_working_path_mode = 'ra'
" Update match window after typing stops for 250ms
let g:ctrlp_lazy_update = 250
" Ignore Mac temp files
let g:ctrlp_mruf_exclude = '\v(\/private)?\/var\/folders\/t\d\/.*'

if executable('rg')
  if !has("win32")
    " FIXME: This doesn't work on Windows. I don't know why!
    " Use rg in CtrlP for listing files.
    let g:ctrlp_user_command = 'rg -F --files %s'

+  55     " FIXME: This is untested on Windows.
    " rg is fast enough that CtrlP doesn't need to cache
    let g:ctrlp_use_caching = 0
  endif
elseif executable('ag')
  if !has("win32")
    " FIXME: This is untested on Windows.
    " Use ag in CtrlP for listing files.
    let g:ctrlp_user_command = 'ag %s -l --nocolor -g ""'

    " ag is fast enough that CtrlP doesn't need to cache
    let g:ctrlp_use_caching = 0
  endif
endif

if !exists("g:ctrlp_user_command")
  " If the variable already exists, it's because we set it to use ripgrep or the
  " Silver Searcher, above. `git ls-files` is actually slightly faster in my
  " testing, but keep using the existing value because it will also find new
  " files that haven't been added to the repository yet.
  let g:ctrlp_user_command = { 'types': { 1: ['.git', 'cd %s && git ls-files'], 2: ['.hg', 'hg --cwd %s locate -I .'], }, 'fallback': 'find %s -type f' }
endif

" Automatic installation
let g:GetLatestVimScripts_allowautoinstall=1

nnoremap <F5> :GundoToggle<CR>

" Default completion type
let g:SuperTabDefaultCompletionType = "context"

" Fallback completion type
let g:SuperTabContextDefaultCompletionType = "<c-p>"
" Use enhanced longest match so you can continue doing longest substring
" after typing more letters
let g:SuperTabLongestEnhanced = 1

nnoremap <leader>tbt :TagbarToggle<CR>

let twitvim_enable_python = 1
let twitvim_browser_cmd = 'firefox.exe'
let twitvim_count = 50

let g:utl_cfg_hdl_mt_generic = "silent !open '%p'"
let g:utl_cfg_hdl_scm_http_system = "silent !open '%u'"

if has('terminal')
  let g:slime_target = "vimterminal"
else
  let g:slime_target = "tmux"
endif

let g:astronomer_super_secret_debug_option=1


" Fold on 3{s and manually
set foldmethod=marker

" Liveblog highlighting {{{

" Find *[Tom's comments]* for liveblogs
" N.B. Had to escape the '|' chars so Vim doesn't think they are pipes
nnoremap <leader>ftc /\v\*\[[^]*]{-}\]\*/s+2<CR>
nnoremap <leader>ftnc /\v(^\[.{-}\]\*\|[^*]\[.{-}\]\*\|\*\[.{-}\]$\|\*\[.{-}\][^*])<CR>

" This is the regular expression used for finding broken comments:
" (^\[.{-}\]\*|[^*]\[.{-}\]\*|\*\[.{-}\]$|\*\[.{-}\][^*])
"
" It's an alternation built from the following four smaller regexps:
"
" Comments missing start asterisks:
" ^\[.{-}\]\*     - at start of line
" [^*]\[.{-}\]\*  - mid line
"
" Comments missing end asterisks:
" \*\[.{-}\]$     - at end of line
" \*\[.{-}\][^*]  - mid line

" }}}

" Filetype options -------------------------------------------------------- {{{

" FIXME: It would be better to use ~/.vim/after/ftplugin/<filetype>.vim files
" for these settings. (So as not to have to use autocommands).

augroup filetypeoptions
  autocmd!

  " C/CPP {{{

  autocmd FileType cpp,c setlocal fo=cq

  " }}}
  " ConqueTerm {{{

  " Turn off listing of trailing spaces
  autocmd FileType conque_term setlocal listchars=tab:->

  " }}}
  " Markdown {{{

  autocmd FileType mkd setlocal ai formatoptions=tcroqnj comments=n:>

  " }}}
  " AutoHotKey {{{

  " Tabs should be converted to a group of 4 spaces.
  autocmd FileType autohotkey setlocal ts=4 sw=4 expandtab
  " }}}
  " Vim {{{

  autocmd FileType vim setlocal foldmethod=marker

  " }}}
  " Objective C {{{

  " Convert tabs to 4 spaces, which is how Xcode is setup by default
  autocmd FileType objc setlocal ts=4 sw=4 expandtab
  autocmd FileType objcpp setlocal ts=4 sw=4 expandtab

  " }}}
augroup END

" }}}

" Source other files ------------------------------------------------------ {{{

" Computer-specific stuff
if filereadable($HOME."/.vim/local.vim")
  source $HOME/.vim/local.vim
endif

" }}}

